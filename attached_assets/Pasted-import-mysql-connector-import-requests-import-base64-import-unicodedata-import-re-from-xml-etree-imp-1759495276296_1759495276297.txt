import mysql.connector
import requests
import base64
import unicodedata
import re
from xml.etree import ElementTree as ET

# =========================
# Config
# =========================
db_config = {
    'host': "localhost",
    'user': "Reservas",
    'password': "!Leonel123",
    'database': "ReservasCA"
}

NEXTCLOUD_URL = "https://contactos.casaaustin.pe/remote.php/dav/addressbooks/users/casaaustin/clientes/"
NEXTCLOUD_USER = "casaaustin"
NEXTCLOUD_PASSWORD = "!Leonel123"

# =========================
# Utilidades
# =========================
def slugify(value: str) -> str:
    value = unicodedata.normalize('NFD', value)
    value = value.encode('ascii', 'ignore').decode('ascii')
    value = re.sub(r'[^a-zA-Z0-9]+', '_', value).strip('_').lower()
    return value

def format_first_word(text: str) -> str:
    """Devuelve solo la primera palabra capitalizada (maneja None/espacios)."""
    if not text:
        return ""
    return text.strip().split()[0].capitalize()

def normalize_phone(phone: str) -> str:
    """Mantiene solo d√≠gitos y '+' inicial si existe. Retorna '' si queda vac√≠o."""
    phone = (phone or "").strip()
    if not phone:
        return ""
    phone = phone.replace(" ", "")
    if phone.startswith('+'):
        digits = re.sub(r'\D', '', phone[1:])
        return ('+' + digits) if digits else ""
    return re.sub(r'\D', '', phone)

def normalize_vcard(text: str) -> str:
    """Normaliza saltos de l√≠nea y espacios de fin para comparar vCards."""
    if text is None:
        return ""
    norm = text.replace('\r\n', '\n').replace('\r', '\n')
    norm = '\n'.join(line.rstrip() for line in norm.split('\n')).strip()
    return norm

# =========================
# DB: contactos + icono del NIVEL M√ÅS ALTO
# =========================
def read_contacts_from_db():
    """
    Retorna lista de tuplas: (client_id:str, first_name, last_name, tel_number, top_icon)
    top_icon puede ser '' si no tiene logros.
    Solo considera contactos con deleted = 0.
    """
    conn = mysql.connector.connect(**db_config)
    cursor = conn.cursor()

    query = """
        SELECT
            c.id,
            c.first_name,
            c.last_name,
            c.tel_number,
            t.icon AS top_icon
        FROM clients_clients c
        LEFT JOIN (
            SELECT
                ca.client_id,
                a.icon,
                ROW_NUMBER() OVER (
                    PARTITION BY ca.client_id
                    ORDER BY
                        a.`order` DESC,
                        a.`required_reservations` DESC,
                        a.`required_referrals` DESC,
                        a.`id` DESC
                ) AS rn
            FROM clients_clientachievement ca
            INNER JOIN clients_achievement a
                ON a.id = ca.achievement_id
        ) AS t
            ON t.client_id = c.id AND t.rn = 1
        WHERE COALESCE(c.deleted, 0) = 0
    """
    cursor.execute(query)
    rows = cursor.fetchall()
    conn.close()

    contacts = []
    for client_id, first_name, last_name, tel_number, top_icon in rows:
        contacts.append((
            str(client_id or "").strip(),    # UUID/string
            first_name or "",
            last_name or "",
            (tel_number or "").strip(),
            top_icon or ""
        ))
    return contacts

# =========================
# vCard
# =========================
def create_vcard(client_id: str, first_name: str, last_name: str, tel_number: str, top_icon: str) -> str:
    """
    N: icono + primer nombre ‚Üí 'üè† Eddy'
    FN: icono + primer nombre y primer apellido ‚Üí 'üè† Eddy Gutierrez'
    UID: estable por client_id (string/UUID)
    """
    given_clean = format_first_word(first_name)
    family_clean = format_first_word(last_name)
    phone = normalize_phone(tel_number)

    if not phone:
        return ""  # omitimos contactos sin tel√©fono v√°lido

    icon = top_icon if top_icon else "ü•ö"  # default si no tiene logro

    # Nombre con icono al inicio
    given_with_icon = f"{icon} {given_clean}".strip()
    display_name = f"{icon} {given_clean} {family_clean}".strip()

    uid = f"casaustin:{client_id}"

    vcard = (
        "BEGIN:VCARD\n"
        "VERSION:3.0\n"
        f"UID:{uid}\n"
        # N: Family;Given;Additional;Prefix;Suffix
        f"N:{family_clean};{given_with_icon};;;\n"
        f"FN:{display_name}\n"
        f"NICKNAME:{display_name}\n"
        f"TEL;TYPE=CELL:{phone}\n"
        "END:VCARD\n"
    )
    return vcard

# =========================
# Nextcloud WebDAV
# =========================
def auth_header():
    token = base64.b64encode(f"{NEXTCLOUD_USER}:{NEXTCLOUD_PASSWORD}".encode()).decode()
    return {'Authorization': f'Basic {token}'}

def list_existing_contacts():
    """Devuelve set con los nombres de archivo .vcf existentes."""
    headers = {**auth_header(), 'Depth': '1'}
    response = requests.request('PROPFIND', NEXTCLOUD_URL, headers=headers)
    if response.status_code != 207:
        print(f"Error listando contactos: {response.status_code} - {response.text}")
        return set()

    files = set()
    try:
        root = ET.fromstring(response.content)
        for resp in root.findall('{DAV:}response'):
            href_el = resp.find('{DAV:}href')
            if href_el is None or not href_el.text:
                continue
            href = href_el.text
            filename = href.rstrip('/').split('/')[-1]
            if filename.lower().endswith('.vcf'):
                files.add(filename)
    except ET.ParseError as e:
        print(f"XML parse error: {e}")
    return files

def fetch_vcard(contact_file: str) -> str:
    url = f"{NEXTCLOUD_URL}{contact_file}"
    r = requests.get(url, headers=auth_header())
    if r.status_code == 200:
        return r.text
    if r.status_code == 404:
        return ""
    print(f"Warning: GET {contact_file} -> {r.status_code}")
    return r.text or ""

def put_vcard(contact_file: str, vcard_text: str) -> bool:
    url = f"{NEXTCLOUD_URL}{contact_file}"
    headers = {
        'Content-Type': 'text/vcard; charset=utf-8',
        **auth_header()
    }
    r = requests.put(url, headers=headers, data=vcard_text.encode('utf-8'))
    if r.status_code in (200, 201, 204):
        return True
    print(f"Error PUT {contact_file}: {r.status_code} - {r.text}")
    return False

# =========================
# Sync (crear/actualizar) usando client_id (string/UUID) como filename
# =========================
def sync_contacts(contacts):
    """
    Archivo: {client_id}.vcf ‚Üí evita duplicados por cambios de nombre/nivel.
    Crea si no existe. Si existe, compara y actualiza solo si cambi√≥ algo.
    Omite contactos sin tel√©fono (log de aviso).
    """
    existing = list_existing_contacts()

    for client_id, first_name, last_name, tel_number, top_icon in contacts:
        cid = (client_id or "").strip()
        if not cid:
            print(f"[OMITIDO] contacto sin client_id. Nombre: {first_name} {last_name}")
            continue

        contact_file = f"{cid}.vcf"
        desired_vcard = create_vcard(cid, first_name, last_name, tel_number, top_icon)

        if not desired_vcard:
            print(f"[OMITIDO] client_id={cid} sin tel√©fono v√°lido. Nombre: {first_name} {last_name}")
            continue

        desired_norm = normalize_vcard(desired_vcard)

        if contact_file not in existing:
            ok = put_vcard(contact_file, desired_vcard)
            print(f"[CREADO] {contact_file}" if ok else f"[ERROR] No se pudo crear {contact_file}")
            continue

        current_vcard = fetch_vcard(contact_file)
        current_norm = normalize_vcard(current_vcard)

        if current_norm != desired_norm:
            ok = put_vcard(contact_file, desired_vcard)
            print(f"[ACTUALIZADO] {contact_file}" if ok else f"[ERROR] Fall√≥ actualizaci√≥n {contact_file}")
        # Si son iguales, no hacemos nada.

# =========================
# Main
# =========================
if __name__ == "__main__":
    contacts = read_contacts_from_db()
    sync_contacts(contacts)